<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Power Supply Holder Configurator - Precision Dimensions</title>
    <style>
        /* Add your CSS styles here */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
            line-height: 1.6;
        }

        .main-wrapper {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header-section {
            text-align: center;
            margin-bottom: 40px;
        }

        .header-section h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #0f172a;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.1rem;
            color: #64748b;
        }

        .section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .section h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #0f172a;
        }

        .section-description {
            color: #64748b;
            margin-bottom: 25px;
        }

        .dimensions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .unit-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .unit-selector label {
            font-weight: 500;
            color: #374151;
        }

        .unit-selector select {
            padding: 8px 12px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .unit-selector select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .dimensions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            font-weight: 500;
            margin-bottom: 8px;
            color: #374151;
        }

        .input-group input,
        .input-group select {
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.2s;
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .thickness-info {
            background: #f0f9ff;
            border: 2px solid #0ea5e9;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .thickness-info-icon {
            font-size: 1.2rem;
            color: #0ea5e9;
        }

        .thickness-info-text {
            color: #0c4a6e;
            font-weight: 500;
        }

        .viewer-section {
            background: white;
            border-radius: 12px;
            margin-bottom: 30px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .viewer-canvas {
            width: 100%;
            height: 650px;
            position: relative;
            background: #f8fafc;
        }

        .loading-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #64748b;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .option-card {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .option-card:hover {
            border-color: #3b82f6;
            background-color: #f8fafc;
        }

        .option-card.active {
            border-color: #3b82f6;
            background-color: #dbeafe;
        }

        .option-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #f9fafb;
        }

        .option-card h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .adapter-count {
            color: #64748b;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .price {
            font-weight: 600;
            color: #059669;
            font-size: 1.1rem;
        }

        .production-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .production-card {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .production-card:hover {
            border-color: #3b82f6;
            background-color: #f8fafc;
        }

        .production-card.active {
            border-color: #3b82f6;
            background-color: #dbeafe;
        }

        .color-options {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .color-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 20px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-option:hover {
            border-color: #3b82f6;
            background-color: #f8fafc;
        }

        .color-option.active {
            border-color: #3b82f6;
            background-color: #dbeafe;
        }

        .color-circle {
            width: 24px;
            height: 24px;
            border-radius: 50%;
        }

        #usage-description {
            width: 100%;
            padding: 15px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-family: inherit;
            font-size: 16px;
            resize: vertical;
            min-height: 100px;
        }

        #usage-description:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .total-section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .total-price {
            font-size: 2rem;
            font-weight: 700;
            color: #059669;
            margin-bottom: 20px;
        }

        .add-to-cart-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.1rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            margin: 0 10px 20px;
            transition: background-color 0.2s;
        }

        .add-to-cart-btn:hover {
            background: #2563eb;
        }

        .export-stl-btn {
            background: #059669;
            color: white;
            display: none;
            border: none;
            padding: 15px 30px;
            font-size: 1.1rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            margin: 0 10px 20px;
            transition: background-color 0.2s;
        }

        .export-stl-btn:hover {
            background: #047857;
        }

        .shipping-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
            color: #64748b;
            font-size: 0.9rem;
        }

        .shipping-item {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .unit-info {
            font-size: 0.85rem;
            color: #6b7280;
            margin-top: 5px;
            font-style: italic;
        }

        .scaling-info {
            background: #fef3c7;
            border: 2px solid #f59e0b;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .scaling-info-title {
            font-weight: 600;
            color: #92400e;
            margin-bottom: 8px;
        }

        .scaling-info-text {
            color: #92400e;
            font-size: 0.9rem;
            line-height: 1.4;
        }
    </style>
</head>
<body>

<div class="main-wrapper">
    <!-- Header Section -->
    <div class="header-section">
        <h1>CUSTOM POWER SUPPLY HOLDER</h1>
        <p class="subtitle">Precision Dimensions - Bevel Compensated System</p>
    </div>

    <!-- Dimensions Section -->
    <div class="section">
        <div class="dimensions-header">
            <div>
                <h2 id="dimensions-title">Your Power Adapter Dimensions (Inches)</h2>
                <p class="section-description">Enter the exact dimensions for your custom power supply holder.</p>
            </div>
            <div class="unit-selector">
                <label for="unit-select">Units:</label>
                <select id="unit-select">
                    <option value="in" selected>Inches (in)</option>
                    <option value="mm">Millimeters (mm)</option>
                    <option value="cm">Centimeters (cm)</option>
                </select>
            </div>
        </div>
        
        <div class="dimensions-grid">
            <div class="input-group">
                <label for="length" id="length-label">Length (in)</label>
                <input type="number" id="length" placeholder="1.97" step="0.01" value="1.97">
                <div class="unit-info" id="length-info">Default: 1.97 in</div>
            </div>
            <div class="input-group">
                <label for="width" id="width-label">Width (in)</label>
                <input type="number" id="width" placeholder="0.98" step="0.01" value="0.98">
                <div class="unit-info" id="width-info">Default: 0.98 in</div>
            </div>
            <div class="input-group">
                <label for="height" id="height-label">Height (in)</label>
                <input type="number" id="height" placeholder="0.59" step="0.01" value="0.59">
                <div class="unit-info" id="height-info">Default: 0.59 in</div>
            </div>
        </div>

    </div>

    <!-- 3D Viewer -->
    <div class="viewer-section">
        <div id="model-container" class="viewer-canvas">
            <div class="loading-text" id="loading-model">
                Loading 3D Model with Precision Dimensions...
            </div>
        </div>
    </div>

    <!-- Configurator Options -->
    <div class="section">
        <h2>Configurator Options</h2>
        <p class="section-description">Choose how many power adapters your holder should accommodate.</p>
        
        <div class="options-grid">
            <div class="option-card active" data-config="single">
                <h3>Single Holder</h3>
                <p class="adapter-count">1 Adapter</p>
                <p class="price">$0</p>
            </div>
            <div class="option-card" data-config="row2">
                <h3>2 in a Row</h3>
                <p class="adapter-count">2 adapters side by side</p>
                <p class="price">$0</p>
            </div>
            <div class="option-card" data-config="row3">
                <h3>3 in a Row</h3>
                <p class="adapter-count">3 adapters in line</p>
                <p class="price">$0</p>
            </div>
            <div class="option-card" data-config="row4">
                <h3>4 in a Row</h3>
                <p class="adapter-count">4 adapters in line</p>
                <p class="price">$0</p>
            </div>
            <div class="option-card" data-config="grid2x2">
                <h3>2×2 Grid</h3>
                <p class="adapter-count">4 adapters in grid</p>
                <p class="price">$0</p>
            </div>
        </div>
    </div>

    <!-- Production Speed -->
    <div class="section">
        <h2>PRODUCTION SPEED</h2>
        
        <div class="production-options">
            <div class="production-card active" data-speed="standard">
                <h3>Standard Production</h3>
                <p>5-10 business days</p>
            </div>
            <div class="production-card" data-speed="rush">
                <h3>Rush Order (+$20)</h3>
                <p>2-3 business days</p>
            </div>
        </div>
    </div>

    <!-- Color Selection -->
    <div class="section">
        <h2>Color Selection</h2>
        
        <div class="color-options">
            <div class="color-option active" data-color="black">
                <div class="color-circle" style="background-color: #1a1a1a;"></div>
                <span>Midnight Black</span>
            </div>
            <div class="color-option" data-color="red">
                <div class="color-circle" style="background-color: #dc2626;"></div>
                <span>Crimson Red</span>
            </div>
            <div class="color-option" data-color="blue">
                <div class="color-circle" style="background-color: #2563eb;"></div>
                <span>Ocean Blue</span>
            </div>
            <div class="color-option" data-color="gray">
                <div class="color-circle" style="background-color: #6b7280;"></div>
                <span>Storm Gray</span>
            </div>
            <div class="color-option" data-color="white">
                <div class="color-circle" style="background-color: #ffffff; border: 2px solid #e5e7eb;"></div>
                <span>Pure White</span>
            </div>
            <div class="color-option" data-color="orange">
                <div class="color-circle" style="background-color: #ea580c;"></div>
                <span>Sunset Orange</span>
            </div>
            <div class="color-option" data-color="green">
                <div class="color-circle" style="background-color: #16a34a;"></div>
                <span>Neon Green</span>
            </div>
        </div>
    </div>

    <!-- Usage Description -->
    <div class="section">
        <h2>USAGE DESCRIPTION (OPTIONAL)</h2>
        <p class="section-description">Tell us how you'll use this power supply holder</p>
        
        <textarea id="usage-description" placeholder="Describe how you plan to use this power supply holder..." rows="4"></textarea>
    </div>

    <!-- Total and Cart -->
    <div class="total-section">
        <div class="total-price">Total: $0.00</div>
        <button class="add-to-cart-btn">Download STL File - $0.00</button>
        <button class="export-stl-btn">Export STL File</button>
        
        <div class="shipping-info">
            <div class="shipping-item">Ships in 5-10 business days</div>
            <div class="shipping-item">Custom manufactured with precision PETG plastic</div>
            <div class="shipping-item">Chemical resistant • Durable • Professional grade</div>
            <div class="shipping-item">Features PRECISION BEVEL COMPENSATION for exact dimensions</div>
            <div class="shipping-item">Fixed 1mm thickness for consistent quality</div>
        </div>
    </div>
</div>

<!-- Three.js Script -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" defer></script>
<script>
// Simple OrbitControls implementation
class SimpleOrbitControls {
    constructor(camera, domElement) {
        this.camera = camera;
        this.domElement = domElement;
        this.target = new THREE.Vector3();
        this.enableDamping = true;
        this.dampingFactor = 0.05;
        this.screenSpacePanning = true;
        this.maxPolarAngle = Math.PI;
        
        this.spherical = new THREE.Spherical();
        this.sphericalDelta = new THREE.Spherical();
        this.scale = 1;
        this.panOffset = new THREE.Vector3();
        
        this.rotateStart = new THREE.Vector2();
        this.rotateEnd = new THREE.Vector2();
        this.rotateDelta = new THREE.Vector2();
        
        this.panStart = new THREE.Vector2();
        this.panEnd = new THREE.Vector2();
        this.panDelta = new THREE.Vector2();
        
        this.dollyStart = new THREE.Vector2();
        this.dollyEnd = new THREE.Vector2();
        this.dollyDelta = new THREE.Vector2();
        
        this.state = 'NONE';
        this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };
        this.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };
        
        this.init();
    }
    
    init() {
        this.domElement.addEventListener('contextmenu', this.onContextMenu.bind(this), false);
        this.domElement.addEventListener('mousedown', this.onMouseDown.bind(this), false);
        this.domElement.addEventListener('wheel', this.onMouseWheel.bind(this), false);
        
        this.domElement.addEventListener('touchstart', this.onTouchStart.bind(this), false);
        this.domElement.addEventListener('touchend', this.onTouchEnd.bind(this), false);
        this.domElement.addEventListener('touchmove', this.onTouchMove.bind(this), false);
    }
    
    update() {
        const offset = new THREE.Vector3();
        const quat = new THREE.Quaternion().setFromUnitVectors(this.camera.up, new THREE.Vector3(0, 1, 0));
        const quatInverse = quat.clone().invert();
        
        const position = this.camera.position;
        offset.copy(position).sub(this.target);
        offset.applyQuaternion(quat);
        
        this.spherical.setFromVector3(offset);
        
        if (this.enableDamping) {
            this.spherical.theta += this.sphericalDelta.theta * this.dampingFactor;
            this.spherical.phi += this.sphericalDelta.phi * this.dampingFactor;
        } else {
            this.spherical.theta += this.sphericalDelta.theta;
            this.spherical.phi += this.sphericalDelta.phi;
        }
        
        this.spherical.phi = Math.max(0, Math.min(Math.PI, this.spherical.phi));
        this.spherical.makeSafe();
        this.spherical.radius *= this.scale;
        
        this.target.add(this.panOffset);
        
        offset.setFromSpherical(this.spherical);
        offset.applyQuaternion(quatInverse);
        
        position.copy(this.target).add(offset);
        this.camera.lookAt(this.target);
        
        if (this.enableDamping) {
            this.sphericalDelta.theta *= (1 - this.dampingFactor);
            this.sphericalDelta.phi *= (1 - this.dampingFactor);
        } else {
            this.sphericalDelta.set(0, 0, 0);
        }
        
        this.scale = 1;
        this.panOffset.set(0, 0, 0);
    }
    
    onMouseDown(event) {
        event.preventDefault();
        
        switch (event.button) {
            case 0: // left
                if (event.ctrlKey || event.metaKey) {
                    this.handleMouseDownPan(event);
                    this.state = 'PAN';
                } else {
                    this.handleMouseDownRotate(event);
                    this.state = 'ROTATE';
                }
                break;
            case 1: // middle
                this.handleMouseDownDolly(event);
                this.state = 'DOLLY';
                break;
            case 2: // right
                this.handleMouseDownPan(event);
                this.state = 'PAN';
                break;
        }
        
        if (this.state !== 'NONE') {
            document.addEventListener('mousemove', this.onMouseMove.bind(this), false);
            document.addEventListener('mouseup', this.onMouseUp.bind(this), false);
        }
    }
    
    onMouseMove(event) {
        event.preventDefault();
        
        switch (this.state) {
            case 'ROTATE':
                this.handleMouseMoveRotate(event);
                break;
            case 'DOLLY':
                this.handleMouseMoveDolly(event);
                break;
            case 'PAN':
                this.handleMouseMovePan(event);
                break;
        }
    }
    
    onMouseUp() {
        document.removeEventListener('mousemove', this.onMouseMove.bind(this), false);
        document.removeEventListener('mouseup', this.onMouseUp.bind(this), false);
        this.state = 'NONE';
    }
    
    onMouseWheel(event) {
        event.preventDefault();
        
        if (event.deltaY < 0) {
            this.dollyIn(this.getZoomScale());
        } else if (event.deltaY > 0) {
            this.dollyOut(this.getZoomScale());
        }
    }
    
    handleMouseDownRotate(event) {
        this.rotateStart.set(event.clientX, event.clientY);
    }
    
    handleMouseMoveRotate(event) {
        this.rotateEnd.set(event.clientX, event.clientY);
        this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(0.31);
        
        const element = this.domElement;
        this.rotateLeft(2 * Math.PI * this.rotateDelta.x / element.clientHeight);
        this.rotateUp(2 * Math.PI * this.rotateDelta.y / element.clientHeight);
        
        this.rotateStart.copy(this.rotateEnd);
    }
    
    handleMouseDownPan(event) {
        this.panStart.set(event.clientX, event.clientY);
    }
    
    handleMouseMovePan(event) {
        this.panEnd.set(event.clientX, event.clientY);
        this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(0.01);
        this.pan(this.panDelta.x, this.panDelta.y);
        this.panStart.copy(this.panEnd);
    }
    
    handleMouseDownDolly(event) {
        this.dollyStart.set(event.clientX, event.clientY);
    }
    
    handleMouseMoveDolly(event) {
        this.dollyEnd.set(event.clientX, event.clientY);
        this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart);
        
        if (this.dollyDelta.y > 0) {
            this.dollyIn(this.getZoomScale());
        } else if (this.dollyDelta.y < 0) {
            this.dollyOut(this.getZoomScale());
        }
        
        this.dollyStart.copy(this.dollyEnd);
    }
    
    onTouchStart(event) {
        switch (event.touches.length) {
            case 1:
                this.handleTouchStartRotate(event);
                this.state = 'TOUCH_ROTATE';
                break;
            case 2:
                this.handleTouchStartDollyPan(event);
                this.state = 'TOUCH_DOLLY_PAN';
                break;
        }
    }
    
    onTouchMove(event) {
        event.preventDefault();
        event.stopPropagation();
        
        switch (event.touches.length) {
            case 1:
                this.handleTouchMoveRotate(event);
                break;
            case 2:
                this.handleTouchMoveDollyPan(event);
                break;
        }
    }
    
    onTouchEnd() {
        this.state = 'NONE';
    }
    
    handleTouchStartRotate(event) {
        this.rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
    }
    
    handleTouchMoveRotate(event) {
        this.rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
        this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(0.01);
        
        const element = this.domElement;
        this.rotateLeft(2 * Math.PI * this.rotateDelta.x / element.clientHeight);
        this.rotateUp(2 * Math.PI * this.rotateDelta.y / element.clientHeight);
        
        this.rotateStart.copy(this.rotateEnd);
    }
    
    handleTouchStartDollyPan(event) {
        const dx = event.touches[0].pageX - event.touches[1].pageX;
        const dy = event.touches[0].pageY - event.touches[1].pageY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        this.dollyStart.set(0, distance);
        
        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        this.panStart.set(x, y);
    }
    
    handleTouchMoveDollyPan(event) {
        const dx = event.touches[0].pageX - event.touches[1].pageX;
        const dy = event.touches[0].pageY - event.touches[1].pageY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        this.dollyEnd.set(0, distance);
        this.dollyDelta.set(0, Math.pow(this.dollyEnd.y / this.dollyStart.y, 0.5));
        
        this.dollyIn(this.dollyDelta.y);
        this.dollyStart.copy(this.dollyEnd);
        
        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        this.panEnd.set(x, y);
        this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(0.01);
        this.pan(this.panDelta.x, this.panDelta.y);
        this.panStart.copy(this.panEnd);
    }
    
    rotateLeft(angle) {
        this.sphericalDelta.theta -= angle;
    }
    
    rotateUp(angle) {
        this.sphericalDelta.phi -= angle;
    }
    
    pan(deltaX, deltaY) {
        const offset = new THREE.Vector3();
        const element = this.domElement;
        
        if (this.camera.isPerspectiveCamera) {
            const position = this.camera.position;
            offset.copy(position).sub(this.target);
            let targetDistance = offset.length();
            
            targetDistance *= Math.tan((this.camera.fov / 2) * Math.PI / 180.0);
            
            const panLeft = new THREE.Vector3();
            panLeft.setFromMatrixColumn(this.camera.matrix, 0);
            panLeft.multiplyScalar(-2 * deltaX * targetDistance / element.clientHeight);
            
            const panUp = new THREE.Vector3();
            panUp.setFromMatrixColumn(this.camera.matrix, 1);
            panUp.multiplyScalar(2 * deltaY * targetDistance / element.clientHeight);
            
            this.panOffset.add(panLeft).add(panUp);
        }
    }
    
    dollyIn(dollyScale) {
        if (this.camera.isPerspectiveCamera) {
            this.scale /= dollyScale;
        }
    }
    
    dollyOut(dollyScale) {
        if (this.camera.isPerspectiveCamera) {
            this.scale *= dollyScale;
        }
    }
    
    getZoomScale() {
        return Math.pow(0.95, 1);
    }
    
    onContextMenu(event) {
        event.preventDefault();
    }
}

// STL Exporter
class STLExporter {
    parse(scene) {
        const meshes = [];
        scene.traverse((child) => {
            if (child.isMesh) {
                meshes.push(child);
            }
        });

        let output = '';
        
        for (let i = 0; i < meshes.length; i++) {
            const mesh = meshes[i];
            const geometry = mesh.geometry.clone();
            mesh.updateMatrixWorld();
            geometry.applyMatrix4(mesh.matrixWorld);
            
            if (geometry.index) {
                geometry = geometry.toNonIndexed();
            }
            
            const vertices = geometry.attributes.position.array;
            const normals = geometry.attributes.normal ? geometry.attributes.normal.array : null;
            
            for (let j = 0; j < vertices.length; j += 9) {
                const normal = normals ? 
                    `${normals[j + 2]} ${normals[j + 5]} ${normals[j + 8]}` : 
                    '0.0 0.0 1.0';
                
                output += `facet normal ${normal}\n`;
                output += '  outer loop\n';
                output += `    vertex ${vertices[j]} ${vertices[j + 1]} ${vertices[j + 2]}\n`;
                output += `    vertex ${vertices[j + 3]} ${vertices[j + 4]} ${vertices[j + 5]}\n`;
                output += `    vertex ${vertices[j + 6]} ${vertices[j + 7]} ${vertices[j + 8]}\n`;
                output += '  endloop\n';
                output += 'endfacet\n';
            }
        }
        
        return `solid exported\n${output}endsolid exported\n`;
    }
}
</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    console.log('Precision Dimensions Configurator Initialized');
    
    // Track user changes
    let userHasChangedDimensions = false;
    
    const container = document.getElementById('model-container');
    const loadingText = document.getElementById('loading-model');
    
    if (!container) {
        console.error('Model container not found!');
        return;
    }
    
    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    
    renderer.setSize(container.offsetWidth, container.offsetHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0xf8fafc, 1);
    
    container.innerHTML = '';
    container.appendChild(renderer.domElement);
    
    // Add FPS counter
    const fpsCounter = document.createElement('div');
    fpsCounter.id = 'fps-counter';
    fpsCounter.style.cssText = `
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: #00ff00;
        padding: 8px 12px;
        border-radius: 4px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        font-weight: bold;
        z-index: 1000;
        user-select: none;
        pointer-events: none;
    `;
    fpsCounter.textContent = 'FPS: --';
    container.appendChild(fpsCounter);
    
    // FPS tracking
    let frameCount = 0;
    let lastTime = performance.now();
    let fps = 0;
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);
    
    const pointLight = new THREE.PointLight(0xffffff, 1.4);
    pointLight.position.set(-5, -5, -2);
    scene.add(pointLight);
    
    // Camera position
    camera.position.set(2, 1, 3);
    
    // Controls
    const controls = new SimpleOrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = true;
    controls.maxPolarAngle = Math.PI;
    
    // Model variables
    let currentModels = [];
    let currentSecondaryModels = [];
    let currentLeftModels = [];
    let currentRoundedModels = [];
    let currentUShapeModels = [];
    let currentConfiguration = 'single';
    let currentColor = 0x1a1a1a;
    let updateTimeout = null;
    
    // Configuration state
    const FIXED_THICKNESS_INCHES = 0.0394; // 1mm in inches
    
    const state = {
        configuration: 'single',
        production: 'standard',
        color: 'black',
        currentUnit: 'in',
        dimensions: { 
            length: 1.9685,   // 50mm in inches
            width: 0.9843,    // 25mm in inches
            height: 0.5906    // 15mm in inches
        }
    };

    // UNIVERSAL SCALING FUNCTIONS
    function getScaledLength(inputLengthInches) {
        return inputLengthInches * 0.8; // 80% scaling
    }

    function getScaledWidth(inputWidthInches) {
        const scaled = inputWidthInches * 1.16;
    return Math.round(scaled * 25.4) / 25.4; 
    }

    function getScaledHeight(inputHeightInches) {
         const scaled = inputHeightInches * 1.2667;
    return Math.round(scaled * 25.4) / 25.4; // 126.67% scaling
    }

    // Unit conversion functions
    const unitConversions = {
        inToCm: (inches) => inches * 2.54,
        inToMm: (inches) => inches * 25.4,
        cmToIn: (cm) => cm / 2.54,
        mmToIn: (mm) => mm / 25.4,
        fromInches: (inches, toUnit) => {
            switch(toUnit) {
                case 'cm': return inches * 2.54;
                case 'mm': return inches * 25.4;
                case 'in': 
                default: return inches;
            }
        },
        toInches: (value, fromUnit) => {
            switch(fromUnit) {
                case 'cm': return value / 2.54;
                case 'mm': return value / 25.4;
                case 'in':
                default: return value;
            }
        }
    };

    // Get scaled dimensions for geometry creation
    function getScaledDimensions() {
        return {
            length: getScaledLength(state.dimensions.length),
            width: getScaledWidth(state.dimensions.width),
            height: getScaledHeight(state.dimensions.height)
        };
    }

    // Calculate secondary width - now returns 19mm initially
    function calculateSecondaryHeightMM(scaledHeightInches) {
        const scaledBaselineHeightInches = getScaledHeight(0.5906); // Scaled 15mm
        const baseHeightMM = 19.0; // Set to 19mm initially
        
        console.log(`Secondary width calculation:`);
        console.log(`Scaled height: ${scaledHeightInches.toFixed(4)} inches (${(scaledHeightInches * 25.4).toFixed(1)}mm)`);
        console.log(`Scaled baseline: ${scaledBaselineHeightInches.toFixed(4)} inches`);
        
        let calculatedWidth;
        
        if (scaledHeightInches <= scaledBaselineHeightInches) {
            calculatedWidth = baseHeightMM;
            console.log(`Height <= scaled baseline: Using secondary width: ${baseHeightMM}mm`);
        } else {
            const heightScale = scaledHeightInches / scaledBaselineHeightInches;
            calculatedWidth = baseHeightMM * heightScale;
            console.log(`Height > scaled baseline: Scale factor = ${heightScale.toFixed(3)}`);
            console.log(`Scaled secondary width: ${calculatedWidth.toFixed(1)}mm`);
        }
        
        // Apply 1% reduction when all inputs are provided
        const hasCompleteInputs = state.dimensions.length > 0 && state.dimensions.width > 0 && state.dimensions.height > 0;
        
        if (hasCompleteInputs) {
            const reducedWidth = calculatedWidth * 1; // 1% reduction
            console.log(`All inputs provided: Applying 1% reduction`);
            console.log(`Before: ${calculatedWidth.toFixed(1)}mm → After: ${reducedWidth.toFixed(1)}mm`);
            calculatedWidth = reducedWidth;
        }
        
        return calculatedWidth;
    }

    // Get visual thickness scaling
    function getVisualThicknessScale(scaledLength, scaledWidth, scaledHeight) {
        const avgDimensionMM = ((scaledLength + scaledWidth + scaledHeight) / 3) * 25.4;
        const baseScale = Math.max(1.0, avgDimensionMM / 50);
        const cappedScale = Math.min(baseScale, 8.0);
        
        console.log(`Visual thickness scale: ${cappedScale.toFixed(2)}x (scaled avg: ${avgDimensionMM.toFixed(1)}mm)`);
        return cappedScale;
    }

    // Calculate Z-axis adjustments with 19mm baseline
    function calculateZAxisAdjustment(scaledHeightInches) {
        const scaledBaselineHeightInches = getScaledHeight(0.5906);
        const baseHeightMM = 19.0; // Use 19mm as baseline
        
        if (scaledHeightInches <= scaledBaselineHeightInches) {
            return { secondary: 0, ushape: 0 };
        }
        
        const currentWidthMM = calculateSecondaryHeightMM(scaledHeightInches);
        const widthIncreaseMM = currentWidthMM - baseHeightMM;
        
        const displayScale = 2 / 100;
        const secondaryZAdjustmentMM = widthIncreaseMM / 2;
        const ushapeZAdjustmentMM = widthIncreaseMM;
        
        console.log(`Z-axis adjustment: Secondary +${(secondaryZAdjustmentMM * displayScale).toFixed(4)}, UShape +${(ushapeZAdjustmentMM * displayScale).toFixed(4)}`);
        
        return { 
            secondary: secondaryZAdjustmentMM * displayScale, 
            ushape: ushapeZAdjustmentMM * displayScale 
        };
    }

    // Get step size for input
    function getStepSize(unit) {
        switch(unit) {
            case 'mm': return 0.1;
            case 'cm': return 0.01;
            case 'in': 
            default: return 0.01;
        }
    }

    // Get precision for display
    function getPrecision(unit) {
        switch(unit) {
            case 'mm': return 1;
            case 'cm': return 2;
            case 'in': 
            default: return 2;
        }
    }

    // Update UI for unit changes
    function updateUIForUnit(unit) {
        const unitNames = {
            'in': 'inches',
            'cm': 'centimeters', 
            'mm': 'millimeters'
        };
        
        const unitSymbols = {
            'in': 'in',
            'cm': 'cm',
            'mm': 'mm'
        };

        document.getElementById('dimensions-title').textContent = 
            `Your Power Adapter Dimensions (${unitNames[unit].charAt(0).toUpperCase() + unitNames[unit].slice(1)})`;

        document.getElementById('length-label').textContent = `Length (${unitSymbols[unit]})`;
        document.getElementById('width-label').textContent = `Width (${unitSymbols[unit]})`;
        document.getElementById('height-label').textContent = `Height (${unitSymbols[unit]})`;

        const step = getStepSize(unit);
        ['length', 'width', 'height'].forEach(dim => {
            const input = document.getElementById(dim);
            input.step = step;
        });

        const precision = getPrecision(unit);
        const defaultLength = unitConversions.fromInches(1.9685, unit).toFixed(precision);
        const defaultWidth = unitConversions.fromInches(0.9843, unit).toFixed(precision);
        const defaultHeight = unitConversions.fromInches(0.5906, unit).toFixed(precision);

        document.getElementById('length-info').textContent = `Default: ${defaultLength} ${unitSymbols[unit]}`;
        document.getElementById('width-info').textContent = `Default: ${defaultWidth} ${unitSymbols[unit]}`;
        document.getElementById('height-info').textContent = `Default: ${defaultHeight} ${unitSymbols[unit]}`;
    }

    // Update input values when unit changes
    function updateInputValues(newUnit) {
        const precision = getPrecision(newUnit);
        
        ['length', 'width', 'height'].forEach(dim => {
            const input = document.getElementById(dim);
            const currentInchValue = state.dimensions[dim];
            const newValue = unitConversions.fromInches(currentInchValue, newUnit);
            input.value = newValue.toFixed(precision);
            input.placeholder = newValue.toFixed(precision);
        });
    }
    
    // Material setup
    const createPlasticMaterial = (color) => {
        return new THREE.MeshPhongMaterial({ 
            color: color,
            shininess: 30,        
            specular: 0x222222,   
            transparent: false,
            opacity: 1.0,
            side: THREE.DoubleSide
        });
    };
    
    // Calculate spacing with scaled dimensions
    function calculateRowSpacing() {
        const scaledDims = getScaledDimensions();
        const scaledWidthInches = scaledDims.width;
        const scaledBaseWidth = getScaledWidth(0.9843); // Scaled baseline
        const baseSpacing = 0.502;
        
        const widthIncreaseFactor = Math.max(0, (scaledWidthInches - scaledBaseWidth) / scaledBaseWidth);
        const reductionRate = -1.00083;
        const spacingReduction = widthIncreaseFactor * reductionRate;
        const maxReduction = 2;
        const actualReduction = Math.min(spacingReduction, maxReduction);
        
        const spacing = baseSpacing * (1 - actualReduction);
        
        console.log(`Row spacing (scaled dims): ${spacing.toFixed(3)} inches`);
        return spacing;
    }

    function calculateGridVerticalSpacing() {
        const scaledDims = getScaledDimensions();
        const scaledLengthInches = scaledDims.length;
        const scaledBaseLength = getScaledLength(1.9685); // Scaled baseline
        const baseSpacing = 1;
        
        const lengthIncreaseFactor = Math.max(0, (scaledLengthInches - scaledBaseLength) / scaledBaseLength);
        const reductionRate = -0.8;
        const spacingReduction = lengthIncreaseFactor * reductionRate;
        const maxReduction = 2;
        const actualReduction = Math.min(spacingReduction, maxReduction);
        
        const spacing = baseSpacing * (1 - actualReduction);
        
        console.log(`Grid spacing (scaled dims): ${spacing.toFixed(3)} inches`);
        return spacing;
    }
    
    // CREATE CENTER PART - Uses scaled dimensions with bevel compensation
    function createPrecisionPart(scaledLength, scaledWidth, scaledHeight) {
        const actualThickness = FIXED_THICKNESS_INCHES ;
        const visualScale = getVisualThicknessScale(scaledLength, scaledWidth, scaledHeight);
        
        console.log(`Creating center part with scaled dimensions: ${scaledLength.toFixed(4)}"×${scaledWidth.toFixed(4)}"×${scaledHeight.toFixed(4)}"`);
        
        const lengthMM = scaledLength * 25.4;
        const widthMM = scaledWidth * 25.4;
        const thicknessMM = actualThickness * 25.4 * visualScale;
        
        const displayScale = 2 / 100;
        const scaledDisplayLength = lengthMM * displayScale;
        const scaledDisplayWidth = widthMM * displayScale;
        const scaledDepth = thicknessMM * displayScale;
        
        const extrudeSettings = {
            depth: scaledDepth,
            bevelEnabled: true,
            bevelThickness: scaledDepth * 0.1,
            bevelSize: scaledDepth * 0.12,
            bevelSegments: 8,
        };

        // PRECISION: Compensate for bevel expansion to achieve exact final dimensions
        const bevelCompensation = (extrudeSettings.bevelSize * 2); // Bevel adds to both sides
        const compensatedDisplayLength = scaledDisplayLength - bevelCompensation;
        const compensatedDisplayWidth = scaledDisplayWidth - bevelCompensation;
        
        console.log(`PRECISION: Center bevel compensation - reducing base by ${bevelCompensation.toFixed(4)} units`);

        const holeRadius = Math.min(compensatedDisplayLength * 0.03, compensatedDisplayWidth * 0.02);
        const holeSpacing = compensatedDisplayLength * 0.4;
        
        const capsuleWidth = Math.min(compensatedDisplayLength * 0.25, compensatedDisplayWidth * 0.6);
        const capsuleHeight = Math.min(compensatedDisplayWidth * 0.3, compensatedDisplayLength * 0.15);
        const capsuleRadius = capsuleHeight / 2;

        const rectShape = new THREE.Shape();
        rectShape.moveTo(-compensatedDisplayLength/2, -compensatedDisplayWidth/2);
        rectShape.lineTo(compensatedDisplayLength/2, -compensatedDisplayWidth/2);
        rectShape.lineTo(compensatedDisplayLength/2, compensatedDisplayWidth/2);
        rectShape.lineTo(-compensatedDisplayLength/2, compensatedDisplayWidth/2);
        rectShape.lineTo(-compensatedDisplayLength/2, -compensatedDisplayWidth/2);

        // Add center holes
        const hole1 = new THREE.Path();
        hole1.absarc(-holeSpacing/2, 0, holeRadius, 0, Math.PI * 2, false);
        
        const hole2 = new THREE.Path();
        hole2.absarc(holeSpacing/2, 0, holeRadius, 0, Math.PI * 2, false);
        
        rectShape.holes.push(hole1);
        rectShape.holes.push(hole2);

        function createCapsuleHole(centerX, centerY) {
            const capsuleHole = new THREE.Path();
            const halfHeight = capsuleHeight / 2;
            const halfWidth = capsuleWidth / 2;
            
            capsuleHole.moveTo(centerX + halfWidth - capsuleRadius, centerY + halfHeight);
            capsuleHole.absarc(centerX + halfWidth - capsuleRadius, centerY, capsuleRadius, Math.PI/2, -Math.PI/2, true);
            capsuleHole.lineTo(centerX - halfWidth + capsuleRadius, centerY - halfHeight);
            capsuleHole.absarc(centerX - halfWidth + capsuleRadius, centerY, capsuleRadius, -Math.PI/2, Math.PI/2, true);
            capsuleHole.lineTo(centerX + halfWidth - capsuleRadius, centerY + halfHeight);
            
            return capsuleHole;
        }

        function createHalfCapsuleHole(centerX, centerY) {
            const halfCapsuleHole = new THREE.Path();
            const halfHeight = capsuleHeight / 2;
            const halfWidth = capsuleWidth / 2;
            
            const cutoffPosition = centerX - halfWidth * 0.85;
            const rightEnd = centerX + halfWidth;
            
            halfCapsuleHole.moveTo(cutoffPosition, centerY + halfHeight);
            halfCapsuleHole.lineTo(rightEnd - capsuleRadius, centerY + halfHeight);
            halfCapsuleHole.absarc(rightEnd - capsuleRadius, centerY, capsuleRadius, Math.PI/2, -Math.PI/2, true);
            halfCapsuleHole.lineTo(cutoffPosition, centerY - halfHeight);
            halfCapsuleHole.lineTo(cutoffPosition, centerY + halfHeight);
            
            return halfCapsuleHole;
        }

        // Add capsule holes (adjusted for compensated dimensions)
        const offsetY = compensatedDisplayWidth * 0.25;
        const offsetX = compensatedDisplayLength * 0.25;
        
        const leftUpperCapsuleHole = createHalfCapsuleHole(-offsetX, offsetY);
        const rightUpperCapsuleHole = createCapsuleHole(offsetX, offsetY);
        const leftLowerCapsuleHole = createHalfCapsuleHole(-offsetX, -offsetY);
        const rightLowerCapsuleHole = createCapsuleHole(offsetX, -offsetY);

        rectShape.holes.push(leftUpperCapsuleHole);
        rectShape.holes.push(rightUpperCapsuleHole);
        rectShape.holes.push(leftLowerCapsuleHole);
        rectShape.holes.push(rightLowerCapsuleHole);

        const geometry = new THREE.ExtrudeGeometry(rectShape, extrudeSettings);
        const positions = geometry.attributes.position.array;
        const backZ = -scaledDepth/2;
        const tolerance = scaledDepth;

        for (let i = 0; i < positions.length; i += 3) {
            const z = positions[i + 2];
            if (z <= backZ + tolerance) {
                positions[i + 2] = backZ; // Flatten back face
            }
        }

        geometry.attributes.position.needsUpdate = true;
        geometry.computeVertexNormals();
        geometry.translate(0, 0, -scaledDepth/2);

        console.log(`Center part created with precision bevel compensation`);
        return geometry;
    }

    // CREATE SECONDARY PART - Uses scaled dimensions with bevel compensation
    function createSecondaryPart(scaledLength, scaledWidth, scaledHeight, flattenBothSides = false) {
        const actualThickness = FIXED_THICKNESS_INCHES;
        const visualScale = getVisualThicknessScale(scaledLength, scaledWidth, scaledHeight);
        
        console.log(`Creating secondary part with scaled dimensions, flattenBothSides: ${flattenBothSides}`);
        
        const fixedLengthMM = scaledLength * 25.4;
        const heightControlledHeightMM = calculateSecondaryHeightMM(scaledHeight);
        const thicknessMM = actualThickness * 25.4 * visualScale;
        
        const displayScale = 2 / 100;
        const scaledDisplayWidth = fixedLengthMM * displayScale;
        const scaledDisplayHeight = heightControlledHeightMM * displayScale;
        const scaledDepth = thicknessMM * displayScale;
        
        const extrudeSettings = {
            depth: scaledDepth,
            bevelEnabled: true,
            bevelThickness: scaledDepth * 0.1,
            bevelSize: scaledDepth * 0.12,
            bevelSegments: 8,
        };

        // PRECISION: Compensate for bevel expansion to achieve exact final dimensions
        const bevelCompensation = (extrudeSettings.bevelSize * 2); // Bevel adds to both sides
        const compensatedDisplayWidth = scaledDisplayWidth - bevelCompensation;
        const compensatedDisplayHeight = scaledDisplayHeight - bevelCompensation;
        
        console.log(`PRECISION: Secondary bevel compensation - reducing base by ${bevelCompensation.toFixed(4)} units`);

        const capsuleWidth = Math.min(compensatedDisplayWidth * 0.25, compensatedDisplayHeight * 1.2);
        const capsuleHeight = Math.min(compensatedDisplayHeight * 0.6, compensatedDisplayWidth * 0.15);
        const capsuleRadius = capsuleHeight / 2;

        function createCapsuleHole(centerX, centerY) {
            const capsuleHole = new THREE.Path();
            const halfHeight = capsuleHeight / 2;
            const halfWidth = capsuleWidth / 2;
            
            capsuleHole.moveTo(centerX + halfWidth - capsuleRadius, centerY + halfHeight);
            capsuleHole.absarc(centerX + halfWidth - capsuleRadius, centerY, capsuleRadius, Math.PI/2, -Math.PI/2, true);
            capsuleHole.lineTo(centerX - halfWidth + capsuleRadius, centerY - halfHeight);
            capsuleHole.absarc(centerX - halfWidth + capsuleRadius, centerY, capsuleRadius, -Math.PI/2, Math.PI/2, true);
            capsuleHole.lineTo(centerX + halfWidth - capsuleRadius, centerY + halfHeight);
            
            return capsuleHole;
        }

        function createHalfCapsuleHole(centerX, centerY) {
            const halfCapsuleHole = new THREE.Path();
            const halfHeight = capsuleHeight / 2;
            const halfWidth = capsuleWidth / 2;
            
            const cutoffPosition = centerX - halfWidth * 0.85;
            const rightEnd = centerX + halfWidth;
            
            halfCapsuleHole.moveTo(cutoffPosition, centerY + halfHeight);
            halfCapsuleHole.lineTo(rightEnd - capsuleRadius, centerY + halfHeight);
            halfCapsuleHole.absarc(rightEnd - capsuleRadius, centerY, capsuleRadius, Math.PI/2, -Math.PI/2, true);
            halfCapsuleHole.lineTo(cutoffPosition, centerY - halfHeight);
            halfCapsuleHole.lineTo(cutoffPosition, centerY + halfHeight);
            
            return halfCapsuleHole;
        }

        const mainShape = new THREE.Shape();
        mainShape.moveTo(-compensatedDisplayWidth/2, -compensatedDisplayHeight/2);
        mainShape.lineTo(compensatedDisplayWidth/2, -compensatedDisplayHeight/2);
        mainShape.lineTo(compensatedDisplayWidth/2, compensatedDisplayHeight/2);
        mainShape.lineTo(-compensatedDisplayWidth/2, compensatedDisplayHeight/2);
        mainShape.lineTo(-compensatedDisplayWidth/2, -compensatedDisplayHeight/2);

        const spacing = compensatedDisplayWidth * 0.25;
        const leftCenterCapsuleHole = createHalfCapsuleHole(-spacing, 0);
        const rightCenterCapsuleHole = createCapsuleHole(spacing, 0);

        mainShape.holes.push(leftCenterCapsuleHole);
        mainShape.holes.push(rightCenterCapsuleHole);
        
        const geometry = new THREE.ExtrudeGeometry(mainShape, extrudeSettings);
        geometry.translate(0, 0, -scaledDepth/2);

        // Flatten faces
        const positions = geometry.attributes.position.array;
        const backZ = -scaledDepth/2;
        const frontZ = scaledDepth/2;
        const tolerance = scaledDepth;
        
        if (flattenBothSides) {
            for (let i = 0; i < positions.length; i += 3) {
                const z = positions[i + 2];
                if (z <= backZ + tolerance) {
                    positions[i + 2] = backZ;
                }
                if (z >= frontZ - tolerance) {
                    positions[i + 2] = frontZ;
                }
            }
        } else {
            for (let i = 0; i < positions.length; i += 3) {
                const z = positions[i + 2];
                if (z <= backZ + tolerance) {
                    positions[i + 2] = backZ;
                }
            }
        }
        
        geometry.attributes.position.needsUpdate = true;
        geometry.computeVertexNormals();

        console.log(`Secondary part created with precision bevel compensation`);
        return geometry;
    }
    
    // CREATE ROUNDED RECTANGLE - Scales with height input (NO bevel compensation)
    function createFlatRoundedRectWithHole(totalLength, totalWidth, height) {
        const actualThickness = 0.01; // Always 1mm
        console.log(`Creating ROUNDED RECTANGLE that scales with height input`);
        
        // CORRECT MAPPING SYSTEM:
        const rectLengthMM = calculateSecondaryHeightMM(height); // Height → Rectangle Length (scales with input)
        const rectWidthMM = totalWidth * 25.4; // Width from input (should be ~29mm for default)
        const thicknessMM = actualThickness * 25.4; // Always 1mm
        
        const displayScale = 2 / 100;
        const scaledLength = rectLengthMM * displayScale;    // X dimension (fixed 19mm)
        const scaledWidth = rectWidthMM * displayScale;     // Y dimension (from width input)
        const scaledDepth = thicknessMM * displayScale;     // Z dimension (always 1mm)
        
        console.log(`ROUNDED RECTANGLE MAPPING (HEIGHT-RESPONSIVE):`);
        console.log(`  Height input → Length: ${rectLengthMM.toFixed(1)}mm (scales with height)`);
        console.log(`  Width input → Width: ${rectWidthMM.toFixed(1)}mm`);
        console.log(`  FIXED thickness: 1.0mm`);
        console.log(`FINAL RECTANGLE: ${rectLengthMM.toFixed(1)}mm × ${rectWidthMM.toFixed(1)}mm × 1.0mm (length scales with height input)`);
        
        // Outer rounded rectangle - laying flat in XY plane
        const outerShape = new THREE.Shape();
        const radius = Math.min(scaledLength, scaledWidth) * 0.05;
        
        // Create rectangle with rounded corners in XY plane
        outerShape.moveTo(-scaledLength/2 + radius, -scaledWidth/2);
        outerShape.lineTo(scaledLength/2 - radius, -scaledWidth/2);
        outerShape.quadraticCurveTo(scaledLength/2, -scaledWidth/2, scaledLength/2, -scaledWidth/2 + radius);
        outerShape.lineTo(scaledLength/2, scaledWidth/2 - radius);
        outerShape.quadraticCurveTo(scaledLength/2, scaledWidth/2, scaledLength/2 - radius, scaledWidth/2);
        outerShape.lineTo(-scaledLength/2 + radius, scaledWidth/2);
        outerShape.quadraticCurveTo(-scaledLength/2, scaledWidth/2, -scaledLength/2, scaledWidth/2 - radius);
        outerShape.lineTo(-scaledLength/2, -scaledWidth/2 + radius);
        outerShape.quadraticCurveTo(-scaledLength/2, -scaledWidth/2, -scaledLength/2 + radius, -scaledWidth/2);

        // Inner hole - centered (proportional to rectangle size)
        const innerShape = new THREE.Shape();
        const innerLength = scaledLength * 0.6; // Hole size
        const innerWidth = scaledWidth * 0.6;   // Hole size
        const innerRadius = Math.min(innerLength, innerWidth) * 0.1;
        
        // Create inner hole with rounded corners
        innerShape.moveTo(-innerLength/2 + innerRadius, -innerWidth/2);
        innerShape.lineTo(innerLength/2 - innerRadius, -innerWidth/2);
        innerShape.quadraticCurveTo(innerLength/2, -innerWidth/2, innerLength/2, -innerWidth/2 + innerRadius);
        innerShape.lineTo(innerLength/2, innerWidth/2 - innerRadius);
        innerShape.quadraticCurveTo(innerLength/2, innerWidth/2, innerLength/2 - innerRadius, innerWidth/2);
        innerShape.lineTo(-innerLength/2 + innerRadius, innerWidth/2);
        innerShape.quadraticCurveTo(-innerLength/2, innerWidth/2, -innerLength/2, innerWidth/2 - innerRadius);
        innerShape.lineTo(-innerLength/2, -innerWidth/2 + innerRadius);
        innerShape.quadraticCurveTo(-innerLength/2, -innerWidth/2, -innerLength/2 + innerRadius, -innerWidth/2);

        outerShape.holes.push(innerShape);

        // Extrude settings - NO bevel compensation for rectangular component
        const extrudeSettings = {
            depth: scaledDepth, // FIXED 1MM thickness
            bevelEnabled: true,
            bevelSegments: 8,
            steps: 1,
            bevelSize: scaledDepth * 0.02,
            bevelThickness: scaledDepth * 0.01
        };

        const geometry = new THREE.ExtrudeGeometry(outerShape, extrudeSettings);
        
        // Center the geometry vertically (Z direction is thickness)
        geometry.translate(0, 0, -scaledDepth/2);

        console.log(`ROUNDED RECTANGLE created: ${rectLengthMM.toFixed(1)}mm × ${rectWidthMM.toFixed(1)}mm × 1mm (NO bevel compensation)`);
        return geometry;
    }

    // CREATE U-SHAPE - Uses scaled dimensions with bevel compensation
    function createUShapedGeometry(scaledWidth, scaledLength, scaledHeight) {
        console.log(`Creating U-shape with scaled dimensions`);
        
        const actualThickness = FIXED_THICKNESS_INCHES;
        const visualScale = getVisualThicknessScale(scaledLength, scaledWidth, scaledHeight);
        
        const adapterWidthMM = scaledWidth * 25.4;
        const handleWidthMM = adapterWidthMM;
        
        let cavityMultiplier;
        if (userHasChangedDimensions) {
            cavityMultiplier = 0.82;
        } else {
            cavityMultiplier = 0.80;
        }
        
        const cavityWidthMM = handleWidthMM * cavityMultiplier;
        const lengthMM = scaledLength * 25.4;
        const thicknessMM = actualThickness * 25.4 * visualScale;
        
        const displayScale = 2 / 100;
        const scaledDisplayWidth = handleWidthMM * displayScale;
        const scaledDisplayLength = lengthMM * displayScale;
        const scaledDepth = thicknessMM * displayScale;
        
        console.log(`U-shape scaled dimensions: ${handleWidthMM.toFixed(1)}mm × ${lengthMM.toFixed(1)}mm`);
        console.log(`Cavity: ${cavityWidthMM.toFixed(1)}mm (${(cavityMultiplier*100).toFixed(0)}%)`);
        
        const shape = new THREE.Shape();
        
        const outerWidth = scaledDisplayWidth; 
        const cavityWidth = (cavityWidthMM * displayScale); 
        const uShapeHeight = scaledDisplayLength * 1;
        const fixedWallThickness3D = 0.04;
        
        // Dynamic bottom wall thickness
        const avgDimensionMM = ((scaledWidth + scaledLength + scaledHeight) / 3) * 25.4;
        const baselineMM = 30;
        const dimensionRatio = avgDimensionMM / baselineMM;
        
        let dynamicBottomScale;
        if (dimensionRatio <= 2.0) {
            dynamicBottomScale = 2.5 + (dimensionRatio - 1.0) * 2.5;
        } else if (dimensionRatio <= 10.0) {
            dynamicBottomScale = 5.0 + (dimensionRatio - 2.0) * 1.875;
        } else {
            dynamicBottomScale = 20.0 + Math.min((dimensionRatio - 10.0) * 2.0, 20.0);
        }
        
        const bottomWallThickness = fixedWallThickness3D * dynamicBottomScale;
        
        // Dynamic radii
        const minRadius = fixedWallThickness3D * 0.3;
        const maxRadius = fixedWallThickness3D * 3.0;
        
        const cavityRadiusScale = cavityWidth * 0.08;
        const innerRadius = Math.max(minRadius, Math.min(maxRadius, cavityRadiusScale));
        
        const overallSizeScale = Math.min(outerWidth, uShapeHeight) * 0.04;
        const openSideBevelRadius = Math.max(minRadius, Math.min(maxRadius, overallSizeScale));
        
        console.log(`Dynamic bottom wall: ${bottomWallThickness.toFixed(4)} units (${dynamicBottomScale.toFixed(1)}x)`);
        console.log(`Dynamic radii: inner=${innerRadius.toFixed(4)}, open side=${openSideBevelRadius.toFixed(4)}`);
        
        const cavityHalfWidth = cavityWidth / 2;
        
        const extrudeSettings = {
            depth: scaledDepth,
            bevelEnabled: true,
            bevelThickness: scaledDepth * 0.1,
            bevelSize: scaledDepth * 0.12, 
            bevelSegments: 8,
        };

        // PRECISION: Compensate for bevel expansion to achieve exact final dimensions
        const bevelCompensation = (extrudeSettings.bevelSize * 2); // Bevel adds to both sides
        const compensatedDisplayWidth = scaledDisplayWidth - bevelCompensation;
        const compensatedUShapeHeight = uShapeHeight - bevelCompensation;
        
        console.log(`PRECISION: U-shape bevel compensation - reducing base by ${bevelCompensation.toFixed(4)} units`);
        
        // Create U-shape (using compensated dimensions)
        shape.moveTo(-compensatedDisplayWidth/2, compensatedUShapeHeight/2);
        shape.lineTo(-compensatedDisplayWidth/2, -compensatedUShapeHeight/2);
        shape.lineTo(compensatedDisplayWidth/2, -compensatedUShapeHeight/2);
        shape.lineTo(compensatedDisplayWidth/2, compensatedUShapeHeight/2);
        
        // Inner cavity (adjusted for compensated dimensions)
        shape.lineTo(cavityHalfWidth + openSideBevelRadius, compensatedUShapeHeight/2);
        shape.quadraticCurveTo(cavityHalfWidth, compensatedUShapeHeight/2, cavityHalfWidth, compensatedUShapeHeight/2 - openSideBevelRadius);
        shape.lineTo(cavityHalfWidth, -compensatedUShapeHeight/2 + bottomWallThickness + innerRadius);
        shape.quadraticCurveTo(cavityHalfWidth, -compensatedUShapeHeight/2 + bottomWallThickness, cavityHalfWidth - innerRadius, -compensatedUShapeHeight/2 + bottomWallThickness);
        shape.lineTo(-cavityHalfWidth + innerRadius, -compensatedUShapeHeight/2 + bottomWallThickness);
        shape.quadraticCurveTo(-cavityHalfWidth, -compensatedUShapeHeight/2 + bottomWallThickness, -cavityHalfWidth, -compensatedUShapeHeight/2 + bottomWallThickness + innerRadius);
        shape.lineTo(-cavityHalfWidth, compensatedUShapeHeight/2 - openSideBevelRadius);
        shape.quadraticCurveTo(-cavityHalfWidth, compensatedUShapeHeight/2, -cavityHalfWidth - openSideBevelRadius, compensatedUShapeHeight/2);
        shape.closePath();

        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const positions = geometry.attributes.position.array;
        const backZ = -scaledDepth/2;
        const frontZ = scaledDepth/2;
        const tolerance = scaledDepth * 0.05; // Much smaller - only 5% of depth

        for (let i = 0; i < positions.length; i += 3) {
            const z = positions[i + 2];
            if (z <= backZ + tolerance) {
                positions[i + 2] = backZ; // Flatten back bevel only
            }
            if (z >= frontZ - tolerance) {
                positions[i + 2] = frontZ; // Flatten front bevel only  
            }
        }

        geometry.attributes.position.needsUpdate = true;
        geometry.computeVertexNormals();
        geometry.translate(0, 0, -scaledDepth/2);

        console.log(`U-shape created with precision bevel compensation`);
        return geometry;
    }
        
    // MAIN UPDATE CONFIGURATION FUNCTION
    function updateConfiguration() {
        console.log('\n=== Configuration Update with Precision Bevel Compensation ===');
        
        // Clear existing models
        [...currentModels, ...currentSecondaryModels, ...currentLeftModels, ...currentRoundedModels, ...currentUShapeModels].forEach(model => {
            scene.remove(model);
        });
        currentModels = [];
        currentSecondaryModels = [];
        currentLeftModels = [];
        currentRoundedModels = [];
        currentUShapeModels = [];
        
        // Get scaled dimensions for all calculations
        const scaledDims = getScaledDimensions();
        
        console.log('Original dimensions:', state.dimensions);
        console.log('Scaled dimensions:', scaledDims);
        console.log(`Scaling applied: Length ${(scaledDims.length/state.dimensions.length*100).toFixed(1)}%, Width ${(scaledDims.width/state.dimensions.width*100).toFixed(1)}%, Height ${(scaledDims.height/state.dimensions.height*100).toFixed(1)}%`);
        console.log(`PRECISION: Bevel compensation applied for exact dimensional accuracy`);
        
        const horizontalSpacing = calculateRowSpacing();
        const verticalSpacing = calculateGridVerticalSpacing();
        
        let positions = [];
        
        switch (state.configuration) {
            case 'single':
                positions = [{ x: 0, y: 0, z: 0 }];
                break;
            case 'row2':
                positions = [
                    { x: -horizontalSpacing/2, y: 0, z: 0 },
                    { x: horizontalSpacing/2, y: 0, z: 0 }
                ];
                break;
            case 'row3':
                positions = [
                    { x: -horizontalSpacing, y: 0, z: 0 },
                    { x: 0, y: 0, z: 0 },
                    { x: horizontalSpacing, y: 0, z: 0 }
                ];
                break;
            case 'row4':
                positions = [
                    { x: -horizontalSpacing*1.5, y: 0, z: 0 },
                    { x: -horizontalSpacing/2, y: 0, z: 0 },
                    { x: horizontalSpacing/2, y: 0, z: 0 },
                    { x: horizontalSpacing*1.5, y: 0, z: 0 }
                ];
                break;
            case 'grid2x2':
                positions = [
                    { x: -horizontalSpacing/2, y: verticalSpacing/2, z: 0 },
                    { x: horizontalSpacing/2, y: verticalSpacing/2, z: 0 },
                    { x: -horizontalSpacing/2, y: -verticalSpacing/2, z: 0 },
                    { x: horizontalSpacing/2, y: -verticalSpacing/2, z: 0 }
                ];
                break;
        }
        
        console.log(`Creating configuration: ${state.configuration} with ${positions.length} adapters`);
        
        // Calculate Z-axis adjustments
        const zAdjustments = calculateZAxisAdjustment(scaledDims.height);
        
        // Dynamic positioning
        const hasCompleteInputs = state.dimensions.length > 0 && state.dimensions.width > 0 && state.dimensions.height > 0;
        
        let dynamicY, dynamicZ, roundedZ_dynamic, secondaryZ, ushapeZ;
        
        if (hasCompleteInputs) {
            console.log(`Complete inputs - applying dynamic positioning with scaled dimensions`);
            
            // Dynamic Y calculation using scaled length
            const scaledLengthMM = scaledDims.length * 25.4;
            const scaledBaselineLengthMM = getScaledLength(1.9685) * 25.4;
            const lengthIncreaseMM = Math.max(0, scaledLengthMM - scaledBaselineLengthMM);
            const lengthIncrease3D = lengthIncreaseMM * (2/100);
            const baseDynamicY = -0.397;
            dynamicY = baseDynamicY - (lengthIncrease3D * 0.5);
            
            // Dynamic Z calculation
            const baseDynamicZ = 0.05;
            dynamicZ = baseDynamicZ + (zAdjustments.ushape * 0.5);
            
            // Z-axis positioning to account for secondary width
            const excessMM = 19.0 - 14.36; // 4.64mm excess
            const excessDisplayUnits = (excessMM * (2/100)); // Convert to display units
            
            console.log(`Z-positioning: Excess ${excessMM.toFixed(2)}mm = ${excessDisplayUnits.toFixed(4)} display units`);
            
            roundedZ_dynamic = dynamicZ + (excessDisplayUnits * 0.3);
            secondaryZ = 0.03 + zAdjustments.secondary + (excessDisplayUnits / 2);
            ushapeZ = 0.1736 + zAdjustments.ushape + excessDisplayUnits;
            
            console.log(`Z-positions: Rounded=${roundedZ_dynamic.toFixed(4)}, Secondary=${secondaryZ.toFixed(4)}, UShape=${ushapeZ.toFixed(4)}`);
            
        } else {
            console.log(`Incomplete inputs - using default positioning`);
            const excessMM = 19.0 - 14.36;
            const excessDisplayUnits = (excessMM * (2/100));
            
            dynamicY = -0.4;
            dynamicZ = 0.03;
            roundedZ_dynamic = 0.029 + (excessDisplayUnits * 0.3);
            secondaryZ = 0.03 + (excessDisplayUnits / 2);
            ushapeZ = 0.176 + excessDisplayUnits;
        }
        
        // Create models for each position using scaled dimensions
        positions.forEach((pos, index) => {
            // Calculate width-based X offsets using scaled dimensions
            const scaledWidthIncrease = scaledDims.width - getScaledWidth(0.9843);
            const widthXOffset = (scaledWidthIncrease * 25.4 * (2/100)) / 2;
            
            // 1. ROUNDED RECTANGLE - with precision dimensions
            const roundedGeometry = createFlatRoundedRectWithHole(
                scaledDims.length,
                scaledDims.width,
                scaledDims.height
            );
            const roundedMaterial = createPlasticMaterial(currentColor);
            const roundedModel = new THREE.Mesh(roundedGeometry, roundedMaterial);
            
            roundedModel.name = `RoundedModel_${index + 1}`;
            const roundedY = (state.configuration === 'grid2x2') ? pos.y + dynamicY : dynamicY;
            roundedModel.position.set(pos.x, roundedY, roundedZ_dynamic);
              roundedModel.scale.set(0.99,0.99,1);
            roundedModel.rotation.x = Math.PI / 2;
            roundedModel.rotation.z = Math.PI / 2;
            
            scene.add(roundedModel);
            currentRoundedModels.push(roundedModel);

            // 2. CENTER MODEL
            const centerGeometry = createPrecisionPart(
                scaledDims.length,
                scaledDims.width,
                scaledDims.height
            );
            const centerMaterial = createPlasticMaterial(currentColor);
            const centerModel = new THREE.Mesh(centerGeometry, centerMaterial);
            
            centerModel.name = `CenterModel_${index + 1}`;
            centerModel.position.set(pos.x, pos.y, pos.z - 0.09852);
            centerModel.scale.set(1, 0.99, 0.75);
            centerModel.rotation.z = Math.PI / 2;
            
            scene.add(centerModel);
            currentModels.push(centerModel);

            // 3. LEFT SIDE MODEL
            const shouldFlattenBothSides = (config, adapterIndex) => {
                if (config === 'single') return false;
                if (config === 'grid2x2') {
                    return adapterIndex === 1 || adapterIndex === 3;
                }
                return adapterIndex > 0;
            };
            
            const flattenLeftModel = shouldFlattenBothSides(state.configuration, index);
            
            const leftGeometry = createSecondaryPart(
                scaledDims.length,
                scaledDims.width,
                scaledDims.height,
                flattenLeftModel
            );
            const leftMaterial = createPlasticMaterial(currentColor);
            const leftModel = new THREE.Mesh(leftGeometry, leftMaterial);
            
            leftModel.name = `LeftModel_${index + 1}`;
            const baseLeftX = pos.x - 0.278;
            const leftX = baseLeftX - widthXOffset ;
            
            leftModel.position.set(leftX, pos.y, secondaryZ);
            leftModel.rotation.z = Math.PI / 2;
            leftModel.rotation.y = -Math.PI / 2;
            
            scene.add(leftModel);
            currentLeftModels.push(leftModel);

            // 4. RIGHT SIDE MODEL (conditional)
            const shouldShowRightModel = (config, adapterIndex) => {
                switch(config) {
                    case 'single': return adapterIndex === 0;
                    case 'row2': return adapterIndex === 1;
                    case 'row3': return adapterIndex === 2;
                    case 'row4': return adapterIndex === 3;
                    case 'grid2x2': return adapterIndex === 1 || adapterIndex === 3;
                    default: return false;
                }
            };

            if (shouldShowRightModel(state.configuration, index)) {
                const rightGeometry = createSecondaryPart(
                    scaledDims.length,
                    scaledDims.width,
                    scaledDims.height,
                    false
                );
                const rightMaterial = createPlasticMaterial(currentColor);
                const rightModel = new THREE.Mesh(rightGeometry, rightMaterial);
                
                rightModel.name = `RightModel_${index + 1}`;
                const baseRightX = pos.x + 0.278;
                const rightX = baseRightX + widthXOffset ;
                
                rightModel.position.set(rightX, pos.y, secondaryZ);
                rightModel.rotation.z = Math.PI / 2;
                rightModel.rotation.y = Math.PI / 2;
                
                scene.add(rightModel);
                currentSecondaryModels.push(rightModel);
            }

            // 5. U-SHAPE MODEL
            const ushapeGeometry = createUShapedGeometry(
                scaledDims.width,
                scaledDims.length,
                scaledDims.height
            );
            const ushapeMaterial = createPlasticMaterial(currentColor);
            const ushapeModel = new THREE.Mesh(ushapeGeometry, ushapeMaterial);
            
            ushapeModel.name = `UShapeModel_${index + 1}`;
            ushapeModel.position.set(pos.x, pos.y, ushapeZ);
            ushapeModel.scale.set(0.99, 1, 1.75);
            
            scene.add(ushapeModel);
            currentUShapeModels.push(ushapeModel);
        });
        
        adjustCameraToFitModels();
        
        console.log(`Configuration complete: ${state.configuration} with precision bevel compensation`);
        console.log(`Models created: ${currentRoundedModels.length} rounded + ${currentModels.length} center + ${currentSecondaryModels.length} right + ${currentLeftModels.length} left + ${currentUShapeModels.length} ushape`);
        console.log('PRECISION: All components have exact dimensions with beveled edges');
        console.log('=== End Configuration Update (PRECISION) ===\n');
    }
    
    function adjustCameraToFitModels() {
        const allModels = [...currentModels, ...currentSecondaryModels, ...currentLeftModels, ...currentRoundedModels, ...currentUShapeModels];
        if (allModels.length === 0) return;
        
        const box = new THREE.Box3();
        allModels.forEach(model => {
            box.expandByObject(model);
        });
        
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        
        const maxSize = Math.max(size.x, size.y, size.z);
        const distance = maxSize * 1.8;
        
        controls.target.copy(center);
        controls.update();
    }
    
    function updateModelColors() {
        console.log(`Updating model colors to: ${state.color}`);
        
        [...currentModels, ...currentSecondaryModels, ...currentLeftModels, ...currentRoundedModels, ...currentUShapeModels].forEach((model, index) => {
            model.material = createPlasticMaterial(currentColor);
        });
    }
    
    function debouncedUpdateDimensions() {
        if (updateTimeout) {
            clearTimeout(updateTimeout);
        }
        
        updateTimeout = setTimeout(() => {
            updateDimensions();
        }, 500);
    }
    
    function updateDimensions() {
        console.log('\n=== Dimensions Update with Precision Bevel Compensation ===');
        console.log('Current dimensions (inches):', state.dimensions);
        console.log('Current configuration:', state.configuration);
        console.log(`User has changed dimensions: ${userHasChangedDimensions}`);
        console.log('PRECISION: Bevel compensation ensures exact STL dimensions');
        
        updateConfiguration();
        
        console.log('=== End Dimensions Update (PRECISION) ===\n');
    }
    
    function exportSTL() {
        console.log('\n=== STL Export with Precision Bevel Compensation ===');
        
        const allModels = [...currentModels, ...currentSecondaryModels, ...currentLeftModels, ...currentRoundedModels, ...currentUShapeModels];
        if (allModels.length === 0) {
            alert('No models to export. Please wait for the model to load.');
            return;
        }
        
        try {
            const exporter = new STLExporter();
            const exportGroup = new THREE.Group();
            
            // Scale factor for export (models are displayed at 2% of real size)
            const DISPLAY_SCALE = 2 / 100;
            const EXPORT_SCALE = 1 / DISPLAY_SCALE;
            
            console.log(`Scaling models for export: ${EXPORT_SCALE}x`);
            
            allModels.forEach((model, index) => {
                const modelClone = model.clone();
                modelClone.scale.multiplyScalar(EXPORT_SCALE);
                modelClone.position.multiplyScalar(EXPORT_SCALE);
                exportGroup.add(modelClone);
            });
            
            // Calculate expected dimensions (using scaled dimensions)
            const scaledDims = getScaledDimensions();
            const expectedLengthMM = scaledDims.length * 25.4;
            const expectedWidthMM = scaledDims.width * 25.4;
            const expectedHeightMM = scaledDims.height * 25.4;
            
            console.log(`Expected STL dimensions (scaled):`);
            console.log(`Length: ${expectedLengthMM.toFixed(1)}mm (${(expectedLengthMM/25.4).toFixed(2)}")`);
            console.log(`Width: ${expectedWidthMM.toFixed(1)}mm (${(expectedWidthMM/25.4).toFixed(2)}")`);
            console.log(`Height: ${expectedHeightMM.toFixed(1)}mm (${(expectedHeightMM/25.4).toFixed(2)}")`);
            console.log(`Applied scaling: L${(scaledDims.length/state.dimensions.length*100).toFixed(0)}%, W${(scaledDims.width/state.dimensions.width*100).toFixed(0)}%, H${(scaledDims.height/state.dimensions.height*100).toFixed(0)}%`);
            console.log(`PRECISION: Secondary parts have exactly 19.00mm width, rounded rectangle is exactly 19.00mm × ${expectedWidthMM.toFixed(1)}mm × 1.00mm`);
            
            const stlString = exporter.parse(exportGroup);
            
            const timestamp = new Date().toISOString().slice(0, 10);
            const filename = `power_supply_holder_PRECISION_${state.configuration}_${state.dimensions.length.toFixed(2)}x${state.dimensions.width.toFixed(2)}x${state.dimensions.height.toFixed(2)}in_${state.color}_${timestamp}.stl`;
            
            const blob = new Blob([stlString], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
            
            console.log(`STL exported successfully: ${filename}`);
            console.log(`File contains PRECISION geometry: exact 19.00mm secondary width, perfect dimensional accuracy`);
            console.log('=== STL Export Complete (PRECISION) ===\n');
            
        } catch (error) {
            console.error('Error exporting STL:', error);
            alert('Error exporting STL file. Please try again.');
        }
    }

    // Animation loop with FPS counter
    function animate() {
        requestAnimationFrame(animate);
        
        // Calculate FPS
        frameCount++;
        const currentTime = performance.now();
        const deltaTime = currentTime - lastTime;
        
        if (deltaTime >= 1000) {
            fps = Math.round((frameCount * 1000) / deltaTime);
            fpsCounter.textContent = `FPS: ${fps}`;
            
            if (fps >= 50) {
                fpsCounter.style.color = '#00ff00';
            } else if (fps >= 30) {
                fpsCounter.style.color = '#ffff00';
            } else {
                fpsCounter.style.color = '#ff0000';
            }
            
            frameCount = 0;
            lastTime = currentTime;
        }
        
        controls.update();
        renderer.render(scene, camera);
    }
    animate();
    
    // Handle window resize
    window.addEventListener('resize', function() {
        const newWidth = container.offsetWidth;
        const newHeight = container.offsetHeight;
        
        camera.aspect = newWidth / newHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(newWidth, newHeight);
    });
    
    // Initialize the first model
    updateConfiguration();
    
    // Hide loading text
    if (loadingText) {
        setTimeout(() => {
            loadingText.style.display = 'none';
        }, 1000);
    }
    
    // Initialize UI interactions
    initializeUI();
    
    function initializeUI() {
        const dimensionInputs = document.querySelectorAll('#length, #width, #height');
        
        // Unit selector
        const unitSelect = document.getElementById('unit-select');
        unitSelect.addEventListener('change', function() {
            const newUnit = this.value;
            const oldUnit = state.currentUnit;
            
            console.log(`Unit changed from ${oldUnit} to ${newUnit}`);
            
            state.currentUnit = newUnit;
            updateUIForUnit(newUnit);
            updateInputValues(newUnit);
            
            dimensionInputs.forEach(input => {
                input.dispatchEvent(new Event('unitChanged'));
            });
        });

        // Configuration options
        const optionCards = document.querySelectorAll('.option-card');
        optionCards.forEach(card => {
            card.addEventListener('click', function() {
                if (this.classList.contains('disabled')) {
                    console.log('Configuration disabled:', this.dataset.config);
                    return;
                }
                
                optionCards.forEach(c => c.classList.remove('active'));
                this.classList.add('active');
                state.configuration = this.dataset.config;
                console.log('Selected configuration:', state.configuration);
                updateConfiguration();
            });
        });
        
        // Production speed
        const productionCards = document.querySelectorAll('.production-card');
        productionCards.forEach(card => {
            card.addEventListener('click', function() {
                productionCards.forEach(c => c.classList.remove('active'));
                this.classList.add('active');
                state.production = this.dataset.speed;
                console.log('Selected production speed:', state.production);
            });
        });
        
        // Color selection
        const colorOptions = document.querySelectorAll('.color-option');
        colorOptions.forEach(option => {
            option.addEventListener('click', function() {
                colorOptions.forEach(c => c.classList.remove('active'));
                this.classList.add('active');
                state.color = this.dataset.color;
                console.log('Selected color:', state.color);
                
                const colorMap = {
                    'black': 0x1a1a1a,
                    'red': 0xdc2626,
                    'blue': 0x2563eb,
                    'gray': 0x6b7280,
                    'white': 0xffffff,
                    'orange': 0xea580c,
                    'green': 0x16a34a
                };
                currentColor = colorMap[this.dataset.color] || 0x1a1a1a;
                updateModelColors();
            });
        });
        
        // Dimension inputs with user change tracking
        dimensionInputs.forEach(input => {
            const setMinValues = () => {
                const minValues = {
                    length: unitConversions.fromInches(1.9685, state.currentUnit),
                    width: unitConversions.fromInches(0.9843, state.currentUnit),  
                    height: unitConversions.fromInches(0.5906, state.currentUnit)
                };
                
                input.min = minValues[input.id].toFixed(getPrecision(state.currentUnit));
            };
            
            setMinValues();
            
            input.addEventListener('input', function() {
                const displayValue = parseFloat(this.value);
                
                // Set flag when user changes any dimension
                userHasChangedDimensions = true;
                console.log(`User changed ${this.id}, scaling flag set`);
                
                if (!isNaN(displayValue) && displayValue > 0) {
                    const minValue = parseFloat(this.min) || 0;
                    
                    if (displayValue >= minValue) {
                        const inchValue = unitConversions.toInches(displayValue, state.currentUnit);
                        state.dimensions[this.id] = inchValue;
                        
                        console.log(`${this.id}: ${displayValue} ${state.currentUnit} = ${inchValue.toFixed(4)} inches`);
                        debouncedUpdateDimensions();
                    }
                }
            });
            
            input.addEventListener('blur', function() {
                const displayValue = parseFloat(this.value);
                const minValue = parseFloat(this.min) || 0;
                
                if (isNaN(displayValue) || displayValue < minValue || this.value === '') {
                    userHasChangedDimensions = true;
                    console.log(`User input corrected for ${this.id}`);
                    
                    this.value = minValue.toFixed(getPrecision(state.currentUnit));
                    const inchValue = unitConversions.toInches(minValue, state.currentUnit);
                    state.dimensions[this.id] = inchValue;
                    updateDimensions();
                }
            });
            
            input.addEventListener('keydown', function(e) {
                if ([8, 9, 27, 13, 46].indexOf(e.keyCode) !== -1 ||
                    (e.keyCode === 65 && e.ctrlKey === true) ||
                    (e.keyCode === 67 && e.ctrlKey === true) ||
                    (e.keyCode === 86 && e.ctrlKey === true) ||
                    (e.keyCode === 88 && e.ctrlKey === true) ||
                    (e.keyCode >= 35 && e.keyCode <= 39)) {
                    return;
                }
                if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105) && e.keyCode !== 190 && e.keyCode !== 110) {
                    e.preventDefault();
                }
            });
            
            input.addEventListener('unitChanged', setMinValues);
        });
        
        // Usage description
        const usageDescription = document.getElementById('usage-description');
        usageDescription.addEventListener('input', function() {
            console.log('Usage description:', this.value);
        });
        
        // Add to cart button (downloads STL)
        const addToCartBtn = document.querySelector('.add-to-cart-btn');
        addToCartBtn.addEventListener('click', function() {
            console.log('Download STL clicked');
            console.log('Current state with precision bevel compensation:', state);
            exportSTL();
        });
        
        // Export STL button
        const exportBtn = document.querySelector('.export-stl-btn');
        exportBtn.addEventListener('click', function() {
            console.log('Export STL clicked');
            exportSTL();
        });

        // Initialize UI for default unit
        updateUIForUnit(state.currentUnit);
    }
    
    console.log('Precision Dimensions Configurator Initialized - COMPLETE VERSION');
    console.log('PRECISION: Bevel compensation ensures exact dimensional accuracy');
    console.log('PRECISION: Secondary width exactly 19.00mm (not 19.24mm)');  
    console.log('PRECISION: All components export at exact specified dimensions with beveled edges');
    console.log('PRECISION: Height exactly 19.00mm, Length exactly 40.00mm for default inputs');
    console.log('Scaling ratios: Length 80%, Width 116%, Height 127%');
    console.log('Fixed 1mm thickness with visual scaling and bevel compensation');
    console.log('All geometry functions receive bevel-compensated dimensions for precision manufacturing');
    console.log('STL export includes exact geometry - no dimensional tolerances');
    console.log('Multi-adapter configurations support precision scaling with bevel compensation');
    console.log('Dynamic positioning adjusted for exact dimensions with collision prevention');
    console.log('Precision bevel compensation maintains visual quality while ensuring exact dimensions');
});
</script>

</body>
</html>